
   Openpux Internet Of Things (IOT) Framework.

   Copyright (C) 2014 Menlo Park Innovation LLC

   menloparkinnovation.com
   menloparkinnovation@gmail.com

Openpux is a Javascript based Internet Of Things (IOT) framework
for connecting devices to the internet over HTTP. It utilizes
Node.js on the server and client side Javascript for the client.

The data model is intended to be open and dynamic similar to
the Javascript language itself using JSON as the main exchange
format.

An optional compact sub-set with a fixed schema is available as
application/x-www-form-urlencoded using HTTP POST for really small
low memory sensors such as Arduino's, etc.

It can be used standalone in memory for local hosting, lab experiments,
prototyping, or connected to a backend cloud data service. "Table"
storage is recommended over SQL as it fits the loose JSON based
object model, though a specific implementation may choose to use
a fixed schema on the back end.

It is intended to be used as a simple set of files in a single
directory with Node.js without the requirement for additional
packages. Additional package dependencies are optional for
additional/advanced features such as cloud storage.

It is well suited for hosting on a small microcontroller running
embedded Linux or other operating systems such as the
Raspberry PI.

Model:

Sensor Exchange

Openpux operates in a client-server model with sensors being the
client with the server in the cloud. This allows low power sensors
to control their connections to keep power consumption low by allowing
their network connection to power down. Sensors will periodically send
updates to the cloud service which records the readings, and are returned
an application defined set of settings.

Application Exchange

An application exchange REST protocol is used to update the sensor
settings and to query the sensor readings. Client side user agents are
provided in HTML/Javascript, but may be any application such as a native
mobile phone/tablet application. ("Rich Client").

Openpux operates around two data tables.

 SensorReadingsTable - Contains sensor readings sent from sensors.

  This table stores multiple readings sent from a given sensor indexed
  by the time the reading arrived at the server. It's updated by
  sensor HTTP POST exchanges either through REST/JSON, or a
  compact form using application/x-www-form-urlencoded.

  It is read by the applications using REST/JSON such as the
  provided HTML/Javascript client agent.

 SensorSettingsTable - Contains settings to return to sensors.

  This table contains the settings returned to a sensor during
  a sensor exchange. It contains a single entry of values for
  a given sensor.

  The SensorSettingsTable is updated by the application REST/JSON
  protocol and a client side user agent is provided in HTML/Javascript,
  but may be any application.

  Schema:

  The schema is organized around key/value pairs. Data is mostly
  simple strings, but can represent any data item or quantity that
  an application can represent as a string.

  The schema is open in order to be flexible for different usage scenarios
  and does impose strict limits as a SQL implementation would. A given
  application may choose to restrict its schema, such as to allow storage
  in an existing SQL implementation.

  There are only four fields defined by the schema:

  AccountID - A user supplied, application dependent account id.

    In the implementation, this is used as a primary/scaling index.

  PassCode - A user suppled, application dependent PassCode.

    In the implementation this is ignored, but can be used to authenticate
    with a cloud service or its storage backend. Typically this is a generated
    "exchange" key based on the application.

  SensorID - A user supplied, application dependent SensorID.

    In the implementation SensorID's are part of AccountID's and
    are used as the per sensor index.

    The combination of AccountID + SensorID represents a primary
    key for lookup.

  TimeAdded - Generated by the server when a record is created/updated.

    This is generated by the server when a record arrives, or is placed
    into the data store.

    It is returned on application queries.
