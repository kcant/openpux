
//
// Menlo: 08/24/2018
//
// Modified to create a shell for hosting the Menlo Gigatron.
//

// This produces a VGA test pattern instead of the Gigatron instance
//`define VGA_TEST_PATTERN 1

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_Nano_Default(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW
);


// Menlo: cleanup warnings
assign ADC_CONVST = 1'b0;
assign ADC_SCK = 1'b0;
assign ADC_SDI = 1'b0;

//=======================================================
//  REG/WIRE declarations
//=======================================================
reg  [31:0]	Cont;

//hdmi
wire [7:0] hdmi_b;
wire [7:0] hdmi_g;
wire [7:0] hdmi_r;
wire       disp_clk;
wire       disp_de;
wire       disp_hs;
wire       disp_vs;
wire       DLY_RST;

// Menlo: Gigatron Main Clock from Altera PLL outclk_2 generated by IP wizard.
wire    clock_6_25Mhz;

//=======================================================
//  Structural coding
//=======================================================
//assign GPIO_0  		=	36'hzzzzzzzz;
//assign GPIO_1  		=	36'hzzzzzzzz;

always@(posedge FPGA_CLK1_50 or negedge KEY[0])
    begin
        if(!KEY[0])
			 Cont	<=	0;
        else
			 Cont	<=	Cont+1;
    end
	 
// Menlo: cleaned this up.
//assign	LED =	KEY[0]? {Cont[25:24],Cont[25:24],
//                             Cont[25:24],Cont[25:24]}: 8'hff;

//assign LED[7:4] = KEY[0]? {Cont[25:24], Cont[25:24]} : 4'b1111;

assign LED[7:4] = 4'b0000;

//	Reset Delay Timer
Reset_Delay			r0	(	
							 .iCLK(FPGA_CLK1_50),
							 .oRESET(DLY_RST));									  

//=======================================================
//  Structural coding
//=======================================================

wire reset_n;

wire pll_1536k;

assign reset_n = 1'b1;
sys_pll u_sys_pll (
   .refclk(FPGA_CLK1_50),
	.rst(1'b0),
	.outclk_0(pll_1536k), // 1.536 Mhz
	.outclk_1(disp_clk),  // vga_clock 25 Mhz
        .outclk_2(clock_6_25Mhz) // Menlo: 6.25 Mhz Gigatron main clock
	);
	
//HDMI I2C	
I2C_HDMI_Config u_I2C_HDMI_Config (
	.iCLK(FPGA_CLK1_50),
	.iRST_N(reset_n),
	.I2C_SCLK(HDMI_I2C_SCL),
	.I2C_SDAT(HDMI_I2C_SDA),
	.HDMI_TX_INT(HDMI_TX_INT)
	);

//
// VGA controller implements a 640x480 8 bit true color dual ported frame buffer.
//
// It can optionally implement a customized palette as well.
//

//
// VGA Frame buffer write variables
//
wire        vga_write_clock;
wire        vga_write_signal;
wire [18:0] vga_write_address;
wire  [7:0] vga_write_data;

vga_controller hdmi_ins(.iRST_n(DLY_RST),
                      .iVGA_CLK(disp_clk),
                      .fpga_clock(FPGA_CLK1_50),
                      .oBLANK_n(disp_de),
                      .oHS(disp_hs),
                      .oVS(disp_vs),
                      .b_data(hdmi_b),
                      .g_data(hdmi_g),
                      .r_data(hdmi_r),
		      .input_framebuffer_write_clock(vga_write_clock),
		      .input_framebuffer_write_signal(vga_write_signal),
                      .input_framebuffer_write_address(vga_write_address),
                      .input_framebuffer_write_data(vga_write_data)
                      );	
							 
assign HDMI_TX_CLK	= disp_clk;
assign HDMI_TX_D	= {hdmi_r,hdmi_g,hdmi_b};
assign HDMI_TX_DE	= disp_de;
assign HDMI_TX_HS	= disp_hs;
assign HDMI_TX_VS	= disp_vs;
	
// Gigatron audio output DAC
wire [3:0]  gigatron_audio_output_dac;

wire [15:0] hdmi_audio_input;
   
assign hdmi_audio_input[15:12] = gigatron_audio_output_dac;
assign hdmi_audio_input[11:0] = 12'hfff;

menlo_hdmi_audio hdmi_audio(
	.reset_n(reset_n),         // input
	.sclk(HDMI_SCLK),          // output (passed through from .clk)
	.lrclk(HDMI_LRCLK),        // output
	.i2s(HDMI_I2S),            // output [3:0]
	.clk(pll_1536k),           // input
        .audio_in(hdmi_audio_input) // input
);
	
//AUDIO_IF u_AVG(
//	.clk(!KEY[0] & pll_1536k), // input
//	.reset_n(reset_n),         // input
//	.sclk(HDMI_SCLK),          // output (passed through from .clk)
//	.lrclk(HDMI_LRCLK),        // output
//	.i2s(HDMI_I2S)             // output [3:0]
//);

  //
  // Menlo Gigatron Project invoked by this shell.
  //

  wire reset;
  assign reset = ~reset_n;

  reg [7:0] gigatron_input_port;

  wire [7:0] gigatron_output_port;
  wire [7:0] gigatron_extended_output_port;

  // RAW VGA signals from the Gigatron
  wire hsync_n;
  wire vsync_n;
  wire [1:0] red;
  wire [1:0] green;
  wire [1:0] blue;

  // BlinkenLights
  wire led5;
  wire led6;
  wire led7;
  wire led8;

  assign LED[0:0] = led5;
  assign LED[1:1] = led6;
  assign LED[2:2] = led7;
  assign LED[3:3] = led8;

  // Serial game controller
  wire ser_pulse;
  wire ser_latch;
  reg ser_data;

  // Gigatron VGA output signals
  wire gigatron_framebuffer_write_clock;
  wire gigatron_framebuffer_write_signal;
  wire [18:0] gigatron_framebuffer_write_address;
  wire [7:0] gigatron_framebuffer_write_data;

`ifdef VGA_TEST_PATTERN

  //
  // Create a VGA color test pattern sequencing through the
  // 8 bit true color palette.
  //
  vga_test_pattern_generator test_pattern(
    .vga_clock(disp_clk), // 25Mhz VGA display clock
    .fpga_clock(FPGA_CLK1_50),
    .gigatron_clock(clock_6_25Mhz), // 6.25Mhz Gigatron Clock
    .reset_n(DLY_RST),    // Active low reset
    .write_clock(vga_write_clock),
    .write_signal(vga_write_signal),
    .write_address(vga_write_address),
    .write_data(vga_write_data)
  );

`else

  //
  // Testing: replace Gigatron framebuffer generator with local test one
  // by setting VGA_TEST_PATTERN.
  //
  // Ok, there appears to be a problem with the Gigatrons VGA framebuffer
  // paths causing a massive latch inferall.
  //
  // But driving the VGA with the test pattern generator and dead ending
  // the Gigatrons signals the design compiles as expected.
  //   
  // In this case this is likely not driving the outputs from the Gigatron VGA
  // with a registered signal.
  //

  assign vga_write_clock = gigatron_framebuffer_write_clock;
  assign vga_write_signal = gigatron_framebuffer_write_signal;
  assign vga_write_address = gigatron_framebuffer_write_address;
  assign vga_write_data = gigatron_framebuffer_write_data;

`endif // VGA_TEST_PATTERN

  Gigatron gigatron(
    .fpga_clock(FPGA_CLK1_50), // 50Mhz FPGA clock
    .vga_clock(disp_clk),      // 25Mhz VGA clock from the PLL
    .clock(clock_6_25Mhz),     // 6.25Mhz Gigatron clock from the PLL
    .reset(reset),
    .run(1'b1),
    .gigatron_input_port(gigatron_input_port),
    .gigatron_output_port(gigatron_output_port),
    .gigatron_extended_output_port(gigatron_extended_output_port),

    // Raw VGA signals from the Gigatron
    .hsync_n(hsync_n),
    .vsync_n(vsync_n),
    .red(red),
    .green(green),
    .blue(blue),

    //
    // Write output to external framebuffer
    //
    // Note: Gigatron outputs its 6.25Mhz clock as VGA clock in this case.
    //
    .framebuffer_write_clock(gigatron_framebuffer_write_clock),
    .framebuffer_write_signal(gigatron_framebuffer_write_signal),
    .framebuffer_write_address(gigatron_framebuffer_write_address),
    .framebuffer_write_data(gigatron_framebuffer_write_data),

    // BlinkenLights
    .led5(led5),
    .led6(led6),
    .led7(led7),
    .led8(led8),

    // 4 bit Audio DAC
    .audio_dac(gigatron_audio_output_dac), // extended_output_port bits 7-4

    // Serial game controller
    .ser_pulse(ser_pulse),
    .ser_latch(ser_latch),
    .ser_data(ser_data)
  );

endmodule // DE10_Nano_Default

//
// VGA test pattern generator
//
module vga_test_pattern_generator(
    input         vga_clock,
    input         fpga_clock,
    input         gigatron_clock,
    input         reset_n,
    output        write_clock,
    output        write_signal,
    output [18:0] write_address,
    output [7:0]  write_data
    );
   
   // VGA clock is the write clock
   assign write_clock = vga_clock;

   // Test Gigatron clock timings
   //assign write_clock = gigatron_clock;

  //
  // Assignments in the always process must be variables (registers)
  // so registers are declared locally, and continuous assigns are used
  // to set the output signals.
  //
  reg [18:0] reg_write_address;
  reg [7:0]  reg_write_data;
  reg        reg_write_signal;

  assign write_address = reg_write_address;
  assign write_data = reg_write_data;
  assign write_signal = reg_write_signal;

  //
  // For test pattern
  //
  reg [31:0] reg_vga_test_counter;
  reg        reg_vga_writing_framebuffer;
   
  //
  // Test pattern loop to verify VGA + framebuffer.
  //
  // Uses the VGA clock.
  //
  // Writes an incrementing 8 bit color pattern in the frame buffer
  // per clock period.
  //
  always@(posedge vga_clock) begin

    if (reset_n == 1'b0) begin
      reg_write_address <= 0;
      reg_write_data <= 0;
      reg_write_signal <= 0;

      reg_vga_test_counter <= 0;
      reg_vga_writing_framebuffer <= 0;
    end
    else begin

      //
      // Not Reset
      //

      //
      // Process sequential write of the current VGA 8 bit value through the frame buffer.
      //
      if (reg_vga_writing_framebuffer != 1'b0) begin

          if (reg_write_signal == 1'b1) begin
              // done with this framebuffer location.
              reg_write_signal <= 1'b0;
              reg_write_address <= reg_write_address + 18'd1;
          end
          else begin

              // Write not asserted, see if we are still writing the framebuffer
              if (reg_write_address == 0) begin
                  reg_vga_writing_framebuffer <= 1'b0; // Done
              end
              else begin
                  reg_write_signal <= 1'b1; // Write current address
              end
          end
      end

      //
      // 25Mhz clock, 8 million clocks == ~1/4 sec
      //
      if (reg_vga_test_counter < 32'h007FFFFF) begin
          reg_vga_test_counter <= reg_vga_test_counter + 1;
      end
      else begin

          //
          // New cycle, increment the color value.
          //
          reg_vga_test_counter <= 0; // reset counter

          // 8 bit wrap around
          reg_write_data <= reg_write_data + 8'd1;
       
          // Indicate we are writing the framebuffer
          reg_vga_writing_framebuffer <= 1;
          reg_write_address <= 0;
          reg_write_signal <= 1;
      end
    end
  end

endmodule // vga_test_pattern_generator
